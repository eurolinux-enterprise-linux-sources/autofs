autofs-5.1.2 - check for conflicting amd section mounts

From: Ian Kent <raven@themaw.net>

Allowing the addition of amd section mounts to the master mounts list
can lead to conflicting mount point paths.

Check for conflicts and skip the amd mount section mounts if a conflict
with the master map mounts is found.

Signed-off-by: Ian Kent <raven@themaw.net>
---
 CHANGELOG        |    1 
 include/master.h |    1 
 lib/master.c     |   59 ++++++++++++++++++++++++++++++++++++++++++++++++++++---
 3 files changed, 58 insertions(+), 3 deletions(-)

--- autofs-5.0.7.orig/CHANGELOG
+++ autofs-5.0.7/CHANGELOG
@@ -228,6 +228,7 @@
 - add function conf_amd_get_map_name().
 - add function conf_amd_get_mount_paths().
 - include amd mount sections mounts in master mounts list.
+- check for conflicting amd section mounts.
 
 25/07/2012 autofs-5.0.7
 =======================
--- autofs-5.0.7.orig/include/master.h
+++ autofs-5.0.7/include/master.h
@@ -106,6 +106,7 @@ void master_source_lock_cleanup(void *);
 void master_source_current_wait(struct master_mapent *);
 void master_source_current_signal(struct master_mapent *);
 struct master_mapent *master_find_mapent(struct master *, const char *);
+unsigned int master_partial_match_mapent(struct master *, const char *);
 struct autofs_point *__master_find_submount(struct autofs_point *, const char *);
 struct autofs_point *master_find_submount(struct autofs_point *, const char *);
 struct amd_entry *__master_find_amdmount(struct autofs_point *, const char *);
--- autofs-5.0.7.orig/lib/master.c
+++ autofs-5.0.7/lib/master.c
@@ -710,6 +710,53 @@ struct master_mapent *master_find_mapent
 	return NULL;
 }
 
+unsigned int master_partial_match_mapent(struct master *master, const char *path)
+{
+	struct list_head *head, *p;
+	size_t path_len = strlen(path);
+	int ret = 0;
+
+	head = &master->mounts;
+	list_for_each(p, head) {
+		struct master_mapent *entry;
+		size_t entry_len;
+		size_t cmp_len;
+
+		entry = list_entry(p, struct master_mapent, list);
+
+		entry_len = strlen(entry->path);
+		cmp_len = min(entry_len, path_len);
+
+		if (!strncmp(entry->path, path, cmp_len)) {
+			/* paths are equal, matching master map entry ? */
+			if (entry_len == path_len) {
+				if (entry->maps &&
+				    entry->maps->flags & MAP_FLAG_FORMAT_AMD)
+					ret = 1;
+				else
+					ret = -1;
+				break;
+			}
+
+			/* amd mount conflicts with entry mount */
+			if (entry_len > path_len &&
+			    *(entry->path + path_len) == '/') {
+				ret = -1;
+				break;
+			}
+
+			/* entry mount conflicts with amd mount */
+			if (entry_len < path_len &&
+			    *(path + entry_len) == '/') {
+				ret = -1;
+				break;
+			}
+		}
+	}
+
+	return ret;
+}
+
 struct autofs_point *__master_find_submount(struct autofs_point *ap, const char *path)
 {
 	struct list_head *head, *p;
@@ -936,10 +983,16 @@ static void master_add_amd_mount_section
 		char *type = NULL;
 		char *map = NULL;
 
-		entry = master_find_mapent(master, path);
-		if (entry) {
+		ret = master_partial_match_mapent(master, path);
+		if (ret) {
+			/* If this amd entry is already present in the
+			 * master map it's not a duplicate, don't issue
+			 * an error message.
+			 */
+			if (ret == 1)
+				goto next;
 			info(m_logopt,
-			     "ignoring duplicate amd section mount %s",
+			     "amd section mount path conflict, %s ignored",
 			     path);
 			goto next;
 		}
