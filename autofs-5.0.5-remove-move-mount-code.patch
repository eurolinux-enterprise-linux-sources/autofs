autofs-5.0.5 - remove move mount code

From: Ian Kent <ikent@redhat.com>

The code to construct a multi-mount tree in a temporary location and then
move it into place is obsolete when using a kernel which includes the
vfs-automount infrastructure.

It is incompatible with systemd and cannot be used if systemd is being used.

So it's being removed.
---

 modules/parse_sun.c |  173 +++-------------------------------------------------
 1 file changed, 10 insertions(+), 163 deletions(-)


--- autofs-5.0.5.orig/modules/parse_sun.c
+++ autofs-5.0.5/modules/parse_sun.c
@@ -37,10 +37,6 @@
 
 #define MODPREFIX "parse(sun): "
 
-#define MOUNT_MOVE_NONE		0x00
-#define MOUNT_MOVE_AUTOFS	0x01
-#define MOUNT_MOVE_OTHER	0x02
-
 int parse_version = AUTOFS_PARSE_VERSION;	/* Required by protocol */
 
 static struct mount_mod *mount_nfs = NULL;
@@ -1047,84 +1043,6 @@ static int parse_mapent(const char *ent,
 	return (p - ent);
 }
 
-static int move_mount(struct autofs_point *ap,
-		      const char *mm_tmp_root, const char *mm_root,
-		      unsigned int move)
-{
-	char buf[MAX_ERR_BUF];
-	int err;
-
-	if (move == MOUNT_MOVE_NONE)
-		return 1;
-
-	err = mkdir_path(mm_root, 0555);
-	if (err < 0 && errno != EEXIST) {
-		error(ap->logopt,
-		      "failed to create move target mount point %s", mm_root);
-		return 0;
-	}
-
-	if (move == MOUNT_MOVE_AUTOFS)
-		err = mount(mm_tmp_root, mm_root, NULL, MS_MOVE, NULL);
-	else
-		err = spawn_mount(ap->logopt,
-				  "--move", mm_tmp_root, mm_root, NULL);
-	if (err) {
-		char *estr = strerror_r(errno, buf, MAX_ERR_BUF);
-		error(ap->logopt,
-		      "failed to move mount from %s to %s: %s",
-		      mm_tmp_root, mm_root, estr);
-		return 0;
-	}
-
-	debug(ap->logopt,
-	      "moved mount tree from %s to %s", mm_tmp_root, mm_root);
-
-	return 1;
-}
-
-static void cleanup_multi_root(struct autofs_point *ap, const char *root,
-					 const char *path, unsigned int move)
-{
-	if (move == MOUNT_MOVE_NONE)
-		return;
-
-	if (move == MOUNT_MOVE_OTHER)
-		spawn_umount(ap->logopt, root, NULL);
-	else {
-		struct ioctl_ops *ops = get_ioctl_ops();
-		struct autofs_point *submount;
-
-		mounts_mutex_lock(ap);
-		submount = __master_find_submount(ap, path);
-		if (!submount) {
-			mounts_mutex_unlock(ap);
-			return;
-		}
-
-		alarm_delete(submount);
-		st_remove_tasks(submount);
-		st_wait_state(submount, ST_READY);
-
-		submount->parent->submnt_count--;
-		list_del_init(&submount->mounts);
-
-		ops->catatonic(submount->logopt, submount->ioctlfd);
-
-		mounts_mutex_unlock(ap);
-
-		if (submount->thid) {
-			pthread_cancel(submount->thid);
-			close_mount_fds(submount);
-			umount(root);
-			destroy_logpri_fifo(submount);
-			master_free_mapent_sources(submount->entry, 1);
-			master_free_mapent(ap->entry);
-		}
-	}
-	return;
-}
-
 static void cleanup_multi_triggers(struct autofs_point *ap,
 			    struct mapent *me, const char *root, int start,
 			    const char *base)
@@ -1164,50 +1082,20 @@ static void cleanup_multi_triggers(struc
 	return;
 }
 
-static int check_fstype_autofs_option(const char *options)
-{
-	char *tok, *tokbuf;
-	int found;
-
-	/*
-	 * Look for fstype= in options and return true if
-	 * the last occurrence is fstype=autofs.
-	 */
-	found = 0;
-	tokbuf = alloca(strlen(options) + 2);
-	strcpy(tokbuf, options);
-	tok = strtok_r(tokbuf, ",", &tokbuf);
-	if (tok) {
-		do {
-			if (strstr(tok, "fstype=")) {
-				if (strstr(tok, "autofs"))
-					found = 1;
-				else
-					found = 0;
-			}
-		} while ((tok = strtok_r(NULL, ",", &tokbuf)));
-	}
-
-	return found;
-}
-
 static int mount_subtree(struct autofs_point *ap, struct mapent *me,
 			 const char *name, char *loc, char *options, void *ctxt)
 {
 	struct mapent *mm;
 	struct mapent *ro;
-	char t_dir[] = "/tmp/autoXXXXXX";
-	char *mnt_tmp_root, *mm_root, *mm_base, *mm_key;
-	const char *mnt_root, *target;
+	char *mm_root, *mm_base, *mm_key;
+	const char *mnt_root;
 	unsigned int mm_root_len, mnt_root_len;
 	int start, ret = 0, rv;
-	unsigned int move;
 
 	rv = 0;
 
 	mm = me->multi;
 	mm_key = mm->key;
-	move = MOUNT_MOVE_NONE;
 
 	if (*mm_key == '/') {
 		mm_root = mm_key;
@@ -1221,22 +1109,12 @@ static int mount_subtree(struct autofs_p
 	}
 	mm_root_len = strlen(mm_root);
 
-	mnt_tmp_root = NULL;
-	if (ap->flags & MOUNT_FLAG_REMOUNT) {
-		mnt_root = mm_root;
-		mnt_root_len = mm_root_len;
-	} else {
-		mnt_root = mkdtemp(t_dir);
-		if (!mnt_root)
-			return 1;
-		mnt_root_len = strlen(mnt_root);
-		mnt_tmp_root = (char *) mnt_root;
-	}
+	mnt_root = mm_root;
+	mnt_root_len = mm_root_len;
 
 	if (me == me->multi) {
 		/* name = NULL */
 		/* destination = mm_root */
-		target = mm_root;
 		mm_base = "/";
 
 		/* Mount root offset if it exists */
@@ -1253,16 +1131,10 @@ static int mount_subtree(struct autofs_p
 				warn(ap->logopt,
 				      MODPREFIX "failed to parse root offset");
 				cache_delete_offset_list(me->mc, name);
-				goto error_out;
+				return 1;
 			}
 			ro_len = strlen(ro_loc);
 
-			if (!(ap->flags & MOUNT_FLAG_REMOUNT)) {
-				move = MOUNT_MOVE_OTHER;
-				if (check_fstype_autofs_option(myoptions))
-					move = MOUNT_MOVE_AUTOFS;
-			}
-
 			tmp = alloca(mnt_root_len + 1);
 			strcpy(tmp, mnt_root);
 			tmp[mnt_root_len] = '/';
@@ -1281,32 +1153,25 @@ static int mount_subtree(struct autofs_p
 				error(ap->logopt, MODPREFIX
 					 "failed to mount offset triggers");
 				cleanup_multi_triggers(ap, me, mnt_root, start, mm_base);
-				cleanup_multi_root(ap, mnt_root, mm_root, move);
-				goto error_out;
+				return 1;
 			}
 		} else if (rv <= 0) {
-			move = MOUNT_MOVE_NONE;
 			ret = mount_multi_triggers(ap, me, mm_root, start, mm_base);
 			if (ret == -1) {
 				error(ap->logopt, MODPREFIX
 					 "failed to mount offset triggers");
 				cleanup_multi_triggers(ap, me, mm_root, start, mm_base);
-				goto error_out;
+				return 1;
 			}
 		}
 	} else {
 		int loclen = strlen(loc);
 		int namelen = strlen(name);
 
-		if (!(ap->flags & MOUNT_FLAG_REMOUNT)) {
-			move = MOUNT_MOVE_OTHER;
-			if (check_fstype_autofs_option(options))
-				move = MOUNT_MOVE_AUTOFS;
-		}
+		mnt_root = name;
 
 		/* name = mm_root + mm_base */
 		/* destination = mm_root + mm_base = name */
-		target = name;
 		mm_base = &me->key[start];
 
 		rv = sun_mount(ap, mnt_root, name, namelen, loc, loclen, options, ctxt);
@@ -1316,14 +1181,11 @@ static int mount_subtree(struct autofs_p
 				error(ap->logopt, MODPREFIX
 					 "failed to mount offset triggers");
 				cleanup_multi_triggers(ap, me, mnt_root, start, mm_base);
-				cleanup_multi_root(ap, mnt_root, mm_root, move);
-				goto error_out;
+				return 1;
 			}
 		} else if (rv < 0) {
 			char *mm_root_base = alloca(strlen(mm_root) + strlen(mm_base) + 1);
 	
-			move = MOUNT_MOVE_NONE;
-
 			strcpy(mm_root_base, mm_root);
 			strcat(mm_root_base, mm_base);
 
@@ -1332,20 +1194,11 @@ static int mount_subtree(struct autofs_p
 				error(ap->logopt, MODPREFIX
 					 "failed to mount offset triggers");
 				cleanup_multi_triggers(ap, me, mm_root, start, mm_base);
-				goto error_out;
+				return 1;
 			}
 		}
 	}
 
-	if (!move_mount(ap, mnt_root, target, move)) {
-		cleanup_multi_triggers(ap, me, mnt_root, start, mm_base);
-		cleanup_multi_root(ap, mnt_root, mm_root, move);
-		goto error_out;
-	}
-
-	if (mnt_tmp_root)
-		rmdir(mnt_tmp_root);
-
 	/* Mount for base of tree failed */
 	if (rv > 0)
 		return rv;
@@ -1358,12 +1211,6 @@ static int mount_subtree(struct autofs_p
 		rv = 0;
 
 	return rv;
-
-error_out:
-	if (mnt_tmp_root)
-		rmdir(mnt_tmp_root);
-
-	return 1;
 }
 
 /*
