autofs-5.1.2 - log functions to prefix messages with attempt_id if available

From: Lars R. Damerow <lars@pixar.com>

Now that there should be a mount attempt id try and include it in log entries.

Signed-off-by: Lars R. Damerow <lars@pixar.com>
Signed-off-by: Ian Kent <raven@themaw.net>
---
 CHANGELOG |    1 
 lib/log.c |  164 +++++++++++++++++++++++++++++++++++++++++++++++++++-----------
 2 files changed, 137 insertions(+), 28 deletions(-)

--- autofs-5.0.7.orig/CHANGELOG
+++ autofs-5.0.7/CHANGELOG
@@ -237,6 +237,7 @@
 - delay submount exit for amd submounts.
 - add the mount requestor's pid to pending_args.
 - create thread-local ID for mount attempts.
+- log functions to prefix messages with attempt_id if available.
 
 25/07/2012 autofs-5.0.7
 =======================
--- autofs-5.0.7.orig/lib/log.c
+++ autofs-5.0.7/lib/log.c
@@ -32,6 +32,26 @@ static unsigned int logging_to_syslog =
 static unsigned int do_verbose = 0;		/* Verbose feedback option */
 static unsigned int do_debug = 0;		/* Full debug output */
 
+static char *prepare_attempt_prefix(const char *msg)
+{
+	unsigned long *attempt_id;
+	char buffer[ATTEMPT_ID_SIZE + 1];
+	char *prefixed_msg = NULL;
+
+	attempt_id = pthread_getspecific(key_thread_attempt_id);
+	if (attempt_id) {
+		int len = sizeof(buffer) + 1 + strlen(msg) + 1;
+
+		snprintf(buffer, ATTEMPT_ID_SIZE, "%02lx", *attempt_id);
+		prefixed_msg = (char *) calloc(len, sizeof(char));
+		strcpy(prefixed_msg, buffer);
+		strcat(prefixed_msg, "|");
+		strcat(prefixed_msg, msg);
+	}
+
+	return prefixed_msg;
+}
+
 void set_log_norm(void)
 {
 	do_verbose = 0;
@@ -72,124 +92,212 @@ void set_log_debug_ap(struct autofs_poin
 void log_info(unsigned int logopt, const char *msg, ...)
 {
 	unsigned int opt_log = logopt & (LOGOPT_DEBUG | LOGOPT_VERBOSE);
+	char *prefixed_msg;
 	va_list ap;
 
 	if (!do_debug && !do_verbose && !opt_log)
 		return;
 
+	prefixed_msg = prepare_attempt_prefix(msg);
+
 	va_start(ap, msg);
-	if (logging_to_syslog)
-		vsyslog(LOG_INFO, msg, ap);
-	else {
-		vfprintf(stderr, msg, ap);
+	if (logging_to_syslog) {
+		if (prefixed_msg)
+			vsyslog(LOG_INFO, prefixed_msg, ap);
+		else
+			vsyslog(LOG_INFO, msg, ap);
+	} else {
+		if (prefixed_msg)
+			vfprintf(stderr, prefixed_msg, ap);
+		else
+			vfprintf(stderr, msg, ap);
 		fputc('\n', stderr);
 	}
 	va_end(ap);
 
+	if (prefixed_msg)
+		free(prefixed_msg);
+
 	return;
 }
 
 void log_notice(unsigned int logopt, const char *msg, ...)
 {
 	unsigned int opt_log = logopt & (LOGOPT_DEBUG | LOGOPT_VERBOSE);
+	char *prefixed_msg;
 	va_list ap;
 
 	if (!do_debug && !do_verbose && !opt_log)
 		return;
 
+	prefixed_msg = prepare_attempt_prefix(msg);
+
 	va_start(ap, msg);
-	if (logging_to_syslog)
-		vsyslog(LOG_NOTICE, msg, ap);
-	else {
-		vfprintf(stderr, msg, ap);
+	if (logging_to_syslog) {
+		if (prefixed_msg)
+			vsyslog(LOG_NOTICE, prefixed_msg, ap);
+		else
+			vsyslog(LOG_INFO, msg, ap);
+	} else {
+		if (prefixed_msg)
+			vfprintf(stderr, prefixed_msg, ap);
+		else
+			vfprintf(stderr, msg, ap);
 		fputc('\n', stderr);
 	}
 	va_end(ap);
 
+	if (prefixed_msg)
+		free(prefixed_msg);
+
 	return;
 }
 
 void log_warn(unsigned int logopt, const char *msg, ...)
 {
 	unsigned int opt_log = logopt & (LOGOPT_DEBUG | LOGOPT_VERBOSE);
+	char *prefixed_msg;
 	va_list ap;
 
 	if (!do_debug && !do_verbose && !opt_log)
 		return;
 
+	prefixed_msg = prepare_attempt_prefix(msg);
+
 	va_start(ap, msg);
-	if (logging_to_syslog)
-		vsyslog(LOG_WARNING, msg, ap);
-	else {
-		vfprintf(stderr, msg, ap);
+	if (logging_to_syslog) {
+		if (prefixed_msg)
+			vsyslog(LOG_WARNING, prefixed_msg, ap);
+		else
+			vsyslog(LOG_INFO, msg, ap);
+	} else {
+		if (prefixed_msg)
+			vfprintf(stderr, prefixed_msg, ap);
+		else
+			vfprintf(stderr, msg, ap);
 		fputc('\n', stderr);
 	}
 	va_end(ap);
 
+	if (prefixed_msg)
+		free(prefixed_msg);
+
 	return;
 }
 
 void log_error(unsigned logopt, const char *msg, ...)
 {
+	char *prefixed_msg;
 	va_list ap;
 
+	prefixed_msg = prepare_attempt_prefix(msg);
+
 	va_start(ap, msg);
-	if (logging_to_syslog)
-		vsyslog(LOG_ERR, msg, ap);
-	else {
-		vfprintf(stderr, msg, ap);
+	if (logging_to_syslog) {
+		if (prefixed_msg)
+			vsyslog(LOG_ERR, prefixed_msg, ap);
+		else
+			vsyslog(LOG_INFO, msg, ap);
+	} else {
+		if (prefixed_msg)
+			vfprintf(stderr, prefixed_msg, ap);
+		else
+			vfprintf(stderr, msg, ap);
 		fputc('\n', stderr);
 	}
 	va_end(ap);
+
+	if (prefixed_msg)
+		free(prefixed_msg);
+
 	return;
 }
 
 void log_crit(unsigned logopt, const char *msg, ...)
 {
+	char *prefixed_msg;
 	va_list ap;
 
+	prefixed_msg = prepare_attempt_prefix(msg);
+
 	va_start(ap, msg);
-	if (logging_to_syslog)
-		vsyslog(LOG_CRIT, msg, ap);
-	else {
-		vfprintf(stderr, msg, ap);
+	if (logging_to_syslog) {
+		if (prefixed_msg)
+			vsyslog(LOG_CRIT, prefixed_msg, ap);
+		else
+			vsyslog(LOG_INFO, msg, ap);
+	} else {
+		if (prefixed_msg)
+			vfprintf(stderr, prefixed_msg, ap);
+		else
+			vfprintf(stderr, msg, ap);
 		fputc('\n', stderr);
 	}
 	va_end(ap);
+
+	if (prefixed_msg)
+		free(prefixed_msg);
+
 	return;
 }
 
 void log_debug(unsigned int logopt, const char *msg, ...)
 {
 	unsigned int opt_log = logopt & LOGOPT_DEBUG;
+	char *prefixed_msg;
 	va_list ap;
 
 	if (!do_debug && !opt_log)
 		return;
 
+	prefixed_msg = prepare_attempt_prefix(msg);
+
 	va_start(ap, msg);
-	if (logging_to_syslog)
-		vsyslog(LOG_WARNING, msg, ap);
-	else {
-		vfprintf(stderr, msg, ap);
+	if (logging_to_syslog) {
+		if (prefixed_msg)
+			vsyslog(LOG_WARNING, prefixed_msg, ap);
+		else
+			vsyslog(LOG_INFO, msg, ap);
+	} else {
+		if (prefixed_msg)
+			vfprintf(stderr, prefixed_msg, ap);
+		else
+			vfprintf(stderr, msg, ap);
 		fputc('\n', stderr);
 	}
 	va_end(ap);
 
+	if (prefixed_msg)
+		free(prefixed_msg);
+
 	return;
 }
 
 void logmsg(const char *msg, ...)
 {
+	char *prefixed_msg;
 	va_list ap;
+
+	prefixed_msg = prepare_attempt_prefix(msg);
+
 	va_start(ap, msg);
-	if (logging_to_syslog)
-		vsyslog(LOG_CRIT, msg, ap);
-	else {
-		vfprintf(stderr, msg, ap);
+	if (logging_to_syslog) {
+		if (prefixed_msg)
+			vsyslog(LOG_CRIT, prefixed_msg, ap);
+		else
+			vsyslog(LOG_INFO, msg, ap);
+	} else {
+		if (prefixed_msg)
+			vfprintf(stderr, prefixed_msg, ap);
+		else
+			vfprintf(stderr, msg, ap);
 		fputc('\n', stderr);
 	}
 	va_end(ap);
+
+	if (prefixed_msg)
+		free(prefixed_msg);
+
 	return;
 }
 
