autofs-5.0.7 - fix wildcard multi map regression

From: Ian Kent <raven@themaw.net>

A recent patch that removed code to add the current map entry when
being parsed if it didn't already exist cause wildcard indirect
multi-mount map entries to fail to mount.

Indirect multi-mount map entries need the entry matched by a wildcard
lookup to be added to the map entry cache because subsequent operations
expect a distinct map entry to be present or they will fail. This is
what the code that was removed did but it did so in the wrong place
which caused a deadlock situation.
---
 CHANGELOG                |    1 +
 modules/lookup_file.c    |   23 ++++++++++++++++-------
 modules/lookup_ldap.c    |   19 +++++++++++++++----
 modules/lookup_nisplus.c |   21 ++++++++++++++++-----
 modules/lookup_sss.c     |   17 ++++++++++++++---
 modules/lookup_yp.c      |   21 ++++++++++++++++-----
 6 files changed, 78 insertions(+), 24 deletions(-)

--- autofs-5.0.5.orig/CHANGELOG
+++ autofs-5.0.5/CHANGELOG
@@ -136,6 +136,7 @@
 - try and cleanup after dumpmaps.
 - teach dumpmaps to output simple key value pairs.
 - syncronize handle_mounts() shutdown.
+- fix wildcard multi map regression.
 
 03/09/2009 autofs-5.0.5
 -----------------------
--- autofs-5.0.5.orig/modules/lookup_file.c
+++ autofs-5.0.5/modules/lookup_file.c
@@ -997,7 +997,7 @@ int lookup_mount(struct autofs_point *ap
 			return NSS_STATUS_UNAVAIL;
 		}
 
-		cache_readlock(mc);
+		cache_writelock(mc);
 		me = cache_lookup_first(mc);
 		if (me && st.st_mtime <= me->age) {
 			/*
@@ -1039,7 +1039,7 @@ int lookup_mount(struct autofs_point *ap
 		}
 	}
 
-	cache_readlock(mc);
+	cache_writelock(mc);
 do_cache_lookup:
 	me = cache_lookup(mc, key);
 	/*
@@ -1055,11 +1055,20 @@ do_cache_lookup:
 		if (!me)
 			me = cache_lookup_distinct(mc, "*");
 	}
-	if (me && me->mapent && (me->source == source || *me->key == '/')) {
-		pthread_cleanup_push(cache_lock_cleanup, mc);
-		strcpy(mapent_buf, me->mapent);
-		mapent = mapent_buf;
-		pthread_cleanup_pop(0);
+	if (me && me->mapent) {
+		/*
+		 * Add wildcard match for later validation checks and
+		 * negative cache lookups.
+		 */
+		if (ap->type == LKP_INDIRECT && *me->key == '*') {
+			ret = cache_update(mc, source, key, me->mapent, me->age);
+			if (!(ret & (CHE_OK | CHE_UPDATED)))
+				me = NULL;
+		}
+		if (me && (me->source == source || *me->key == '/')) {
+			strcpy(mapent_buf, me->mapent);
+			mapent = mapent_buf;
+		}
 	}
 	cache_unlock(mc);
 
--- autofs-5.0.5.orig/modules/lookup_ldap.c
+++ autofs-5.0.5/modules/lookup_ldap.c
@@ -2958,7 +2958,7 @@ int lookup_mount(struct autofs_point *ap
 			return status;
 	}
 
-	cache_readlock(mc);
+	cache_writelock(mc);
 	me = cache_lookup(mc, key);
 	/* Stale mapent => check for entry in alternate source or wildcard */
 	if (me && !me->mapent) {
@@ -2968,9 +2968,20 @@ int lookup_mount(struct autofs_point *ap
 		if (!me)
 			me = cache_lookup_distinct(mc, "*");
 	}
-	if (me && me->mapent && (me->source == source || *me->key == '/')) {
-		strcpy(mapent_buf, me->mapent);
-		mapent = mapent_buf;
+	if (me && me->mapent) {
+		/*
+		 * Add wildcard match for later validation checks and
+		 * negative cache lookups.
+		 */
+		if (ap->type == LKP_INDIRECT && *me->key == '*') {
+			ret = cache_update(mc, source, key, me->mapent, me->age);
+			if (!(ret & (CHE_OK | CHE_UPDATED)))
+				me = NULL;
+		}
+		if (me && (me->source == source || *me->key == '/')) {
+			strcpy(mapent_buf, me->mapent);
+			mapent = mapent_buf;
+		}
 	}
 	cache_unlock(mc);
 
--- autofs-5.0.5.orig/modules/lookup_nisplus.c
+++ autofs-5.0.5/modules/lookup_nisplus.c
@@ -561,7 +561,7 @@ int lookup_mount(struct autofs_point *ap
 			return status;
 	}
 
-	cache_readlock(mc);
+	cache_writelock(mc);
 	me = cache_lookup(mc, key);
 	/* Stale mapent => check for entry in alternate source or wildcard */
 	if (me && !me->mapent) {
@@ -571,10 +571,21 @@ int lookup_mount(struct autofs_point *ap
 		if (!me)
 			me = cache_lookup_distinct(mc, "*");
 	}
-	if (me && me->mapent && (me->source == source || *me->key == '/')) {
-		mapent_len = strlen(me->mapent);
-		mapent = malloc(mapent_len + 1);
-		strcpy(mapent, me->mapent);
+	if (me && me->mapent) {
+		/*
+		 * Add wildcard match for later validation checks and
+		 * negative cache lookups.
+		 */
+		if (ap->type == LKP_INDIRECT && *me->key == '*') {
+			ret = cache_update(mc, source, key, me->mapent, me->age);
+			if (!(ret & (CHE_OK | CHE_UPDATED)))
+				me = NULL;
+		}
+		if (me && (me->source == source || *me->key == '/')) {
+			mapent_len = strlen(me->mapent);
+			mapent = malloc(mapent_len + 1);
+			strcpy(mapent, me->mapent);
+		}
 	}
 	cache_unlock(mc);
 
--- autofs-5.0.5.orig/modules/lookup_sss.c
+++ autofs-5.0.5/modules/lookup_sss.c
@@ -643,9 +643,20 @@ int lookup_mount(struct autofs_point *ap
 		if (!me)
 			me = cache_lookup_distinct(mc, "*");
 	}
-	if (me && me->mapent && (me->source == source || *me->key == '/')) {
-		strcpy(mapent_buf, me->mapent);
-		mapent = mapent_buf;
+	if (me && me->mapent) {
+		/*
+		 * Add wildcard match for later validation checks and
+		 * negative cache lookups.
+		 */
+		if (ap->type == LKP_INDIRECT && *me->key == '*') {
+			ret = cache_update(mc, source, key, me->mapent, me->age);
+			if (!(ret & (CHE_OK | CHE_UPDATED)))
+				me = NULL;
+		}
+		if (me && (me->source == source || *me->key == '/')) {
+			strcpy(mapent_buf, me->mapent);
+			mapent = mapent_buf;
+		}
 	}
 	cache_unlock(mc);
 
--- autofs-5.0.5.orig/modules/lookup_yp.c
+++ autofs-5.0.5/modules/lookup_yp.c
@@ -662,7 +662,7 @@ int lookup_mount(struct autofs_point *ap
 			return status;
 	}
 
-	cache_readlock(mc);
+	cache_writelock(mc);
 	me = cache_lookup(mc, key);
 	/* Stale mapent => check for entry in alternate source or wildcard */
 	if (me && !me->mapent) {
@@ -672,10 +672,21 @@ int lookup_mount(struct autofs_point *ap
 		if (!me)
 			me = cache_lookup_distinct(mc, "*");
 	}
-	if (me && me->mapent && (me->source == source || *me->key == '/')) {
-		mapent_len = strlen(me->mapent);
-		mapent = alloca(mapent_len + 1);
-		strcpy(mapent, me->mapent);
+	if (me && me->mapent) {
+		/*
+		 * Add wildcard match for later validation checks and
+		 * negative cache lookups.
+		 */
+		if (ap->type == LKP_INDIRECT && *me->key == '*') {
+			ret = cache_update(mc, source, key, me->mapent, me->age);
+			if (!(ret & (CHE_OK | CHE_UPDATED)))
+				me = NULL;
+		}
+		if (me && (me->source == source || *me->key == '/')) {
+			mapent_len = strlen(me->mapent);
+			mapent = alloca(mapent_len + 1);
+			strcpy(mapent, me->mapent);
+		}
 	}
 	cache_unlock(mc);
 
