autofs-5.0.7 - fix submount tree not all expiring

From: Ian Kent <ikent@redhat.com>

Due to the change in the expire-specific-submount-only patch, sub-mounts
within an indirect mount that follow a submount (in the check order) won't
be expired if that submount is busy.
---
 CHANGELOG    |    1 +
 lib/master.c |   24 +++++++++++++++---------
 2 files changed, 16 insertions(+), 9 deletions(-)

--- autofs-5.0.5.orig/CHANGELOG
+++ autofs-5.0.5/CHANGELOG
@@ -154,6 +154,7 @@
 - fix reset flex scan buffer on init.
 - fix fix negative status being reset on map read.
 - fix kernel verion check of version components.
+- fix submount tree not all expiring.
 
 03/09/2009 autofs-5.0.5
 -----------------------
--- autofs-5.0.5.orig/lib/master.c
+++ autofs-5.0.5/lib/master.c
@@ -904,15 +904,24 @@ int master_notify_submount(struct autofs
 		this = list_entry(p, struct autofs_point, mounts);
 		p = p->prev;
 
-		if (!master_submount_list_empty(this)) {
-			mounts_mutex_unlock(ap);
-			return master_notify_submount(this, path, state);
-		}
-
 		/* path not the same */
 		if (strcmp(this->path, path))
 			continue;
 
+		if (!master_submount_list_empty(this)) {
+			char *this_path = strdup(this->path);
+			if (this_path) {
+				mounts_mutex_unlock(ap);
+				master_notify_submount(this, path, state);
+				mounts_mutex_lock(ap);
+				if (!__master_find_submount(ap, this_path)) {
+					free(this_path);
+					continue;
+				}
+				free(this_path);
+			}
+		}
+
 		/* Now we have found the submount we want to expire */
 
 		st_mutex_lock();
@@ -958,10 +967,7 @@ int master_notify_submount(struct autofs
 			st_mutex_lock();
 		}
 		st_mutex_unlock();
-		mounts_mutex_unlock(ap);
-
-		return ret;
-
+		break;
 	}
 
 	mounts_mutex_unlock(ap);
