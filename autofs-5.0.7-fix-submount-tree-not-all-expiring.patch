autofs-5.0.7 - fix submount tree not all expiring

From: Ian Kent <ikent@redhat.com>

Due to the change in the expire-specific-submount-only patch, sub-mounts
within an indirect mount that follow a submount (in the check order) won't
be expired if that submount is busy.
---
 CHANGELOG    |    1 +
 lib/master.c |   24 +++++++++++++++---------
 2 files changed, 16 insertions(+), 9 deletions(-)

diff --git a/CHANGELOG b/CHANGELOG
index f1ec1e5..4106e7f 100644
--- a/CHANGELOG
+++ b/CHANGELOG
@@ -39,6 +39,7 @@
 - document browse option in man page.
 - fix some automount(8) typos.
 - syncronize handle_mounts() shutdown.
+- fix submount tree not all expiring.
 
 25/07/2012 autofs-5.0.7
 =======================
diff --git a/lib/master.c b/lib/master.c
index a0e62f2..64dbcb1 100644
--- a/lib/master.c
+++ b/lib/master.c
@@ -905,15 +905,24 @@ int master_notify_submount(struct autofs_point *ap, const char *path, enum state
 		this = list_entry(p, struct autofs_point, mounts);
 		p = p->prev;
 
-		if (!master_submount_list_empty(this)) {
-			mounts_mutex_unlock(ap);
-			return master_notify_submount(this, path, state);
-		}
-
 		/* path not the same */
 		if (strcmp(this->path, path))
 			continue;
 
+		if (!master_submount_list_empty(this)) {
+			char *this_path = strdup(this->path);
+			if (this_path) {
+				mounts_mutex_unlock(ap);
+				master_notify_submount(this, path, state);
+				mounts_mutex_lock(ap);
+				if (!__master_find_submount(ap, this_path)) {
+					free(this_path);
+					continue;
+				}
+				free(this_path);
+			}
+		}
+
 		/* Now we have found the submount we want to expire */
 
 		st_mutex_lock();
@@ -959,10 +968,7 @@ int master_notify_submount(struct autofs_point *ap, const char *path, enum state
 			st_mutex_lock();
 		}
 		st_mutex_unlock();
-		mounts_mutex_unlock(ap);
-
-		return ret;
-
+		break;
 	}
 
 	mounts_mutex_unlock(ap);
