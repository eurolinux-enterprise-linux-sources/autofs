autofs-5.0.9 - amd lookup add search_path handling

From: Ian Kent <raven@themaw.net>


---
 daemon/lookup.c                |   75 +++++++++++++++++++++++++++++++----------
 include/master.h               |    1 
 lib/master.c                   |    6 +++
 man/autofs.conf.5.in           |    5 ++
 modules/parse_amd.c            |    4 +-
 redhat/autofs.conf.default.in  |    9 +---
 samples/autofs.conf.default.in |    9 +---
 7 files changed, 79 insertions(+), 30 deletions(-)

--- autofs-5.0.5.orig/daemon/lookup.c
+++ autofs-5.0.5/daemon/lookup.c
@@ -100,25 +100,64 @@ static int do_read_master(struct master
 	return status;
 }
 
-static char *find_map_path(struct map_source *map)
+static char *find_map_path(struct autofs_point *ap, struct map_source *map)
 {
+	const char *mname = map->argv[0];
+	unsigned int mlen = strlen(mname);
+	char *tok, *ptr = NULL;
+	char *path = NULL;
+	char *search_path;
 	struct stat st;
-	char *path;
 
-	path = malloc(strlen(AUTOFS_MAP_DIR) + strlen(map->argv[0]) + 2);
-	if (!path)
+	/*
+	 * This is different to the way it is in amd.
+	 * autofs will always try to locate maps in AUTOFS_MAP_DIR
+	 * but amd has no default and will not find a file map that
+	 * isn't a full path when no search_path is configured, either
+	 * in the mount point or global configuration.
+	 */
+	search_path = strdup(AUTOFS_MAP_DIR);
+	if (map->flags & MAP_FLAG_FORMAT_AMD) {
+		struct autofs_point *pap = ap;
+		char *tmp;
+		/*
+		 * Make sure we get search_path from the root of the
+		 * mount tree, if one is present in the configuration.
+		 * Again different from amd, which ignores the submount
+		 * case.
+		 */
+		while (pap->parent)
+			pap = pap->parent;
+		tmp = conf_amd_get_search_path(pap->path);
+		if (tmp) {
+			if (search_path)
+				free(search_path);
+			search_path = tmp;
+		}
+	}
+	if (!search_path)
 		return NULL;
 
-	strcpy(path, AUTOFS_MAP_DIR);
-	strcat(path, "/");
-	strcat(path, map->argv[0]);
-
-	if (!stat(path, &st))
-		return path;
-
-	free(path);
+	tok = strtok_r(search_path, ":", &ptr);
+	while (tok) {
+		char *this = malloc(strlen(tok) + mlen + 2);
+		if (!this) {
+			free(search_path);
+			return NULL;
+		}
+		strcpy(this, tok);
+		strcat(this, "/");
+		strcat(this, mname);
+		if (!stat(this, &st)) {
+			path = this;
+			break;
+		}
+		free(this);
+		tok = strtok_r(NULL, ":", &ptr);
+	}
 
-	return NULL;
+	free(search_path);
+	return path;
 }
 
 static int read_master_map(struct master *master, char *type, time_t age)
@@ -433,7 +472,7 @@ static int lookup_map_read_map(struct au
 	if (map->argv[0][0] == '/')
 		return do_read_map(ap, map, age);
 
-	path = find_map_path(map);
+	path = find_map_path(ap, map);
 	if (!path)
 		return NSS_STATUS_UNKNOWN;
 
@@ -477,6 +516,7 @@ static enum nsswitch_status read_map_sou
 	tmap.flags = map->flags;
 	tmap.type = this->source;
 	tmap.format = map->format;
+	tmap.name = map->name;
 	tmap.lookup = map->lookup;
 	tmap.mc = map->mc;
 	tmap.instance = map->instance;
@@ -487,7 +527,7 @@ static enum nsswitch_status read_map_sou
 	tmap.argc = 0;
 	tmap.argv = NULL;
 
-	path = find_map_path(map);
+	path = find_map_path(ap, map);
 	if (!path)
 		return NSS_STATUS_UNKNOWN;
 
@@ -836,7 +876,7 @@ static int do_name_lookup_mount(struct a
 	if (map->argv[0][0] == '/')
 		return do_lookup_mount(ap, map, name, name_len);
 
-	path = find_map_path(map);
+	path = find_map_path(ap, map);
 	if (!path)
 		return NSS_STATUS_UNKNOWN;
 
@@ -881,6 +921,7 @@ static enum nsswitch_status lookup_map_n
 	tmap.flags = map->flags;
 	tmap.type = this->source;
 	tmap.format = map->format;
+	tmap.name = map->name;
 	tmap.mc = map->mc;
 	tmap.instance = map->instance;
 	tmap.exp_timeout = map->exp_timeout;
@@ -889,7 +930,7 @@ static enum nsswitch_status lookup_map_n
 	tmap.argc = 0;
 	tmap.argv = NULL;
 
-	path = find_map_path(map);
+	path = find_map_path(ap, map);
 	if (!path)
 		return NSS_STATUS_UNKNOWN;
 
--- autofs-5.0.5.orig/include/master.h
+++ autofs-5.0.5/include/master.h
@@ -26,6 +26,7 @@ struct map_source {
 	unsigned int flags;
 	char *type;
 	char *format;
+	char *name;
 	time_t exp_timeout;		/* Timeout for expiring mounts */
 	time_t age;
 	unsigned int master_line;
--- autofs-5.0.5.orig/lib/master.c
+++ autofs-5.0.5/lib/master.c
@@ -211,6 +211,8 @@ master_add_map_source(struct master_mape
 	}
 	source->argc = argc;
 	source->argv = tmpargv;
+	if (source->argv[0])
+		source->name = strdup(source->argv[0]);
 
 	master_source_writelock(entry);
 
@@ -333,6 +335,8 @@ static void __master_free_map_source(str
 		free(source->type);
 	if (source->format)
 		free(source->format);
+	if (source->name)
+		free(source->name);
 	if (free_cache && source->mc)
 		cache_release(source);
 	if (source->lookup) {
@@ -468,6 +472,8 @@ master_add_source_instance(struct map_so
 	}
 	new->argc = argc;
 	new->argv = tmpargv;
+	if (source->name)
+		new->name = strdup(source->name);
 
 	status = pthread_mutex_lock(&instance_mutex);
 	if (status)
--- autofs-5.0.5.orig/man/autofs.conf.5.in
+++ autofs-5.0.5/man/autofs.conf.5.in
@@ -327,6 +327,11 @@ and can be used to provide different def
 without having to modify centrally managed maps. It is empty by
 default.
 .TP
+.B search_path
+.br
+Colon seperated paths to search for maps that are not specified
+as a full path.
+.TP
 .B dismount_interval
 .br
 Is equivalent to the autofs timeout option. It is only possible
--- autofs-5.0.5.orig/modules/parse_amd.c
+++ autofs-5.0.5/modules/parse_amd.c
@@ -198,7 +198,9 @@ static struct substvar *add_lookup_vars(
 		break;
 	}
 
-	if (source->argv[0][0])
+	if (source->name)
+		list = macro_addvar(list, "map", 3, source->name);
+	else if (source->argv[0][0])
 		list = macro_addvar(list, "map", 3, source->argv[0]);
 
 	tsv = pthread_getspecific(key_thread_stdenv_vars);
--- autofs-5.0.5.orig/redhat/autofs.conf.default.in
+++ autofs-5.0.5/redhat/autofs.conf.default.in
@@ -221,12 +221,6 @@ mount_nfs_default_protocol = 4
 #
 # A number of configuration options are not yet implemented:
 #
-# search_path - always a little frustrating, the compiled in
-#	map location should be used to locate maps but isn't
-#	in some cases. This requires work within autofs itself
-#	and that will (obviously) include implementing this
-#	configuration option for the amd map parser as well.
-#
 # fully_qualified_hosts - not yet implemented.
 #
 # unmount_on_exit - since autofs always tries to re-connect
@@ -269,6 +263,9 @@ mount_nfs_default_protocol = 4
 #	machines without having to modify centrally managed maps.
 #	It is empty by default.
 #
+# search_path - colon seperated paths to search for maps that
+#	are not specified as a full path.
+#
 # dismount_interval - is equivalent to the autofs timeout option. It
 #	is only possible to use this with type "auto" mounts due
 #	to the way the autofs kernel module performs expiry. It
--- autofs-5.0.5.orig/samples/autofs.conf.default.in
+++ autofs-5.0.5/samples/autofs.conf.default.in
@@ -220,12 +220,6 @@ browse_mode = no
 #
 # A number of configuration options are not yet implemented:
 #
-# search_path - always a little frustrating, the compiled in
-#	map location should be used to locate maps but isn't
-#	in some cases. This requires work within autofs itself
-#	and that will (obviously) include implementing this
-#	configuration option for the amd map parser as well.
-#
 # fully_qualified_hosts - not yet implemented.
 #
 # unmount_on_exit - since autofs always tries to re-connect
@@ -268,6 +262,9 @@ browse_mode = no
 #	machines without having to modify centrally managed maps.
 #	It is empty by default.
 #
+# search_path - colon seperated paths to search for maps that
+#	are not specified as a full path.
+#
 # dismount_interval - is equivalent to the autofs timeout option. It
 #	is only possible to use this with type "auto" mounts due
 #	to the way the autofs kernel module performs expiry. It
