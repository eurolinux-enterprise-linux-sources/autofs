autofs-5.0.5 - fix null map entry order handling

From: Ian Kent <ikent@redhat.com>

If a null map entry appears after a corresponding indirect map entry
autofs doesn't handle it properly.

Since it appears after the map entry it should'nt affect it but autofs
doesn't account for this case and assumes the map entry is already
mounted and tries to shut it down causing attempted access to facilities
that don't exist.
---

 CHANGELOG    |    1 +
 lib/master.c |   32 +++++++++++++++++++++++++++++---
 2 files changed, 30 insertions(+), 3 deletions(-)


--- autofs-5.0.5.orig/CHANGELOG
+++ autofs-5.0.5/CHANGELOG
@@ -113,6 +113,7 @@
 - fix devce ioctl alloc path check.
 - add hup signal handling to hosts map.
 - fix offset directory removal.
+- fix null map entry order handling.
 
 03/09/2009 autofs-5.0.5
 -----------------------
--- autofs-5.0.5.orig/lib/master.c
+++ autofs-5.0.5/lib/master.c
@@ -1169,9 +1169,35 @@ int master_mount_mounts(struct master *m
 
 		cache_readlock(nc);
 		ne = cache_lookup_distinct(nc, this->path);
-		if (ne && this->age > ne->age) {
+		/*
+		 * If this path matched a nulled entry the master map entry
+		 * must be an indirect mount so the master map entry line
+		 * number may be obtained from this->maps.
+		 */
+		if (ne) {
+			int lineno = ne->age;
 			cache_unlock(nc);
-			st_add_task(ap, ST_SHUTDOWN_PENDING);
+
+			/* null entry appears after map entry */
+			if (this->maps->master_line < lineno) {
+				warn(ap->logopt,
+				     "ignoring null entry that appears after "
+				     "existing entry for %s", this->path);
+				goto cont;
+			}
+			if (ap->state != ST_INIT) {
+				st_add_task(ap, ST_SHUTDOWN_PENDING);
+				continue;
+			}
+			/*
+			 * The map entry hasn't been started yet and we've
+			 * seen a preceeding null map entry for it so just
+			 * delete it from the master map entry list so it
+			 * doesn't get in the road.
+			 */
+			list_del_init(&this->list);
+			master_free_mapent_sources(ap->entry, 1);
+			master_free_mapent(ap->entry);
 			continue;
 		}
 		nested = cache_partial_match(nc, this->path);
@@ -1184,7 +1210,7 @@ int master_mount_mounts(struct master *m
 				cache_delete(nc, nested->key);
 		}
 		cache_unlock(nc);
-
+cont:
 		st_mutex_lock();
 
 		state_pipe = this->ap->state_pipe[1];
