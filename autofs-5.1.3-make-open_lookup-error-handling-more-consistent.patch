autofs-5.1.3 - make open_lookup() error handling more consistent

From: Ian Kent <raven@themaw.net>

If the open of a lookup module fails then open_lookup() should return
an NSS status that causes the source to be skipped as it is most likely
due to the map source not being configured.

Currently open_lookup() returns NSS_STATUS_UNAVAIL for failures whereas
much of the other lookup code returns NSS_STATUS_UNKNOWN for similar
errors encountered by open_lookup().

But NSS_STATUS_UNAVAIL will result in waiting for the lookup module to
become avaiable when trying to read the master map at startup even
though it isn't likely to become available. So NSS_STATUS_UNKNOWN is
more appropriate becuase that will cause the source to be skipped and
is used for the same purpose elsewhere.

Signed-off-by: Ian Kent <raven@themaw.net>
---
 CHANGELOG       |    1 +
 daemon/module.c |   14 +++++++-------
 2 files changed, 8 insertions(+), 7 deletions(-)

--- autofs-5.0.7.orig/CHANGELOG
+++ autofs-5.0.7/CHANGELOG
@@ -259,6 +259,7 @@
 - revert fix argc off by one in mount_autofs.c.
 - only take master map mutex for master map update.
 - fix nisplus lookup init not configured check.
+- make open_lookup() error handling more consistent.
 
 25/07/2012 autofs-5.0.7
 =======================
--- autofs-5.0.7.orig/daemon/module.c
+++ autofs-5.0.7/daemon/module.c
@@ -73,7 +73,7 @@ int open_lookup(const char *name, const
 			char *estr = strerror_r(errno, buf, MAX_ERR_BUF);
 			logerr("%s%s", err_prefix, estr);
 		}
-		return NSS_STATUS_UNAVAIL;
+		return NSS_STATUS_UNKNOWN;
 	}
 
 	type = strdup(name);
@@ -83,7 +83,7 @@ int open_lookup(const char *name, const
 			char *estr = strerror_r(errno, buf, MAX_ERR_BUF);
 			logerr("%s%s", err_prefix, estr);
 		}
-		return NSS_STATUS_UNAVAIL;
+		return NSS_STATUS_UNKNOWN;
 	}
 
 	size = snprintf(fnbuf, sizeof(fnbuf),
@@ -95,7 +95,7 @@ int open_lookup(const char *name, const
 			char *estr = strerror_r(errno, buf, MAX_ERR_BUF);
 			logerr("%s%s", err_prefix, estr);
 		}
-		return NSS_STATUS_UNAVAIL;
+		return NSS_STATUS_UNKNOWN;
 	}
 
 	if (!(dh = dlopen(fnbuf, RTLD_NOW))) {
@@ -104,7 +104,7 @@ int open_lookup(const char *name, const
 			       err_prefix, name, dlerror());
 		free(mod);
 		free(type);
-		return NSS_STATUS_UNAVAIL;
+		return NSS_STATUS_UNKNOWN;
 	}
 
 	if (!(ver = (int *) dlsym(dh, "lookup_version"))
@@ -115,7 +115,7 @@ int open_lookup(const char *name, const
 		dlclose(dh);
 		free(mod);
 		free(type);
-		return NSS_STATUS_UNAVAIL;
+		return NSS_STATUS_UNKNOWN;
 	}
 
 	if (!(mod->lookup_init = (lookup_init_t) dlsym(dh, "lookup_init")) ||
@@ -129,14 +129,14 @@ int open_lookup(const char *name, const
 		dlclose(dh);
 		free(mod);
 		free(type);
-		return NSS_STATUS_UNAVAIL;
+		return NSS_STATUS_UNKNOWN;
 	}
 
 	if (mod->lookup_init(mapfmt, argc, argv, &mod->context)) {
 		dlclose(dh);
 		free(mod);
 		free(type);
-		return NSS_STATUS_NOTFOUND;
+		return NSS_STATUS_UNKNOWN;
 	}
 
 	mod->type = type;
